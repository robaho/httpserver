plugins {
    id 'maven-publish'
    id 'signing'
    id 'java-library'
    id 'tech.yanand.maven-central-publish' version '1.3.0'
}

repositories {
    mavenCentral() 
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
    withSourcesJar()
    withJavadocJar()
}

tasks.withType(JavaCompile) {
    options.compilerArgs += "--enable-preview"
}

tasks.withType(Test) {
    jvmArgs += "--enable-preview"
    jvmArgs += "--add-opens=jdk.httpserver/com.sun.net.httpserver=ALL-UNNAMED"
    systemProperty("java.util.logging.config.file","logging.properties")
    systemProperty("com.sun.net.httpserver.HttpServerProvider","robaho.net.httpserver.DefaultHttpServerProvider")
    systemProperty("robaho.net.httpserver.http2OverSSL","true")
    systemProperty("robaho.net.httpserver.http2OverNonSSL","true")
    // systemProperty("robaho.net.httpserver.http2MaxConcurrentStreams","5000")
    // systemProperty("robaho.net.httpserver.http2DisableFlushDelay","true")
    // systemProperty("robaho.net.httpserver.http2OverSSL","true")
    systemProperty("robaho.net.httpserver.http2OverNonSSL","true")
    // systemProperty("javax.net.debug","ssl:handshake:verbose:keymanager:trustmanager")
}

tasks.withType(JavaExec) {
    jvmArgs += "--enable-preview"
    systemProperty("java.util.logging.config.file","logging.properties")
    systemProperty("com.sun.net.httpserver.HttpServerProvider","robaho.net.httpserver.DefaultHttpServerProvider")
    // systemProperty("robaho.net.httpserver.http2OverSSL","true")
    systemProperty("robaho.net.httpserver.http2OverNonSSL","true")
    systemProperty("robaho.net.httpserver.http2InitialWindowSize","1024000")
    systemProperty("robaho.net.httpserver.http2ConnectionWindowSize","1024000000")
    systemProperty("robaho.net.httpserver.EnableStats","true")
    systemProperty("robaho.net.httpserver.EnableDebug","true")
}

dependencies {
    testImplementation 'org.testng:testng:7.8.0'
}

configurations {
    testMainsCompile.extendsFrom testCompile
    testMainsRuntime.extendsFrom testMainsCompile
}

test {
    useTestNG()
    testLogging {
        // events "passed", "skipped", "failed", "standard_out", "standard_error"
        events "failed"
    }
}

sourceSets {
    main {
        java {
            srcDirs = [ 'src/main/java' ]
        }
    }
    test {
        java {
            srcDirs = [ 
                'src/test/extras', 
                'src/test/java', 
                'src/test/java_default/bugs', 
                'src/test/java_default/HttpExchange'
            ]
        }
    }
    create('testMains') {
      java {
        srcDirs = ['src/test/test_mains']
        compileClasspath = test.output + main.output + configurations.testMainsCompile
        runtimeClasspath = output + compileClasspath + configurations.testMainsRuntime
      }
      resources {
            srcDirs = [ 'src/test/resources' ]
      }
    }
}

// Use a lazy Provider to get the git version. This is the modern, configuration-cache-friendly approach.
def gitVersionProvider = project.providers.exec {
    // 1. Describe the latest revision with a tag
    commandLine = ['git', 'describe', '--tags', '--always']
    ignoreExitValue = true // Don't fail the build if git fails (e.g., no tags exist)
}.standardOutput.asText.map { it.trim() }

// Apply the git version to your project
version = gitVersionProvider.get()

task showGitVersion {
    doLast {
        println "project version is "+version
    }
}

build {
}

jar {
    manifest {
        attributes(
            "Implementation-Title": project.name,
            "Implementation-Version": version)
    }
}

task runSingleUnitTest(type: Test) {
    outputs.upToDateWhen { false }
    dependsOn testClasses
    filter {
        includeTestsMatching 'PipeliningStallTest'
    }
    useTestNG()
}

/** used for development to run a single test */
task runSingleMainTest(type: Test) { 
    outputs.upToDateWhen { false }
    dependsOn testMainsClasses
    doLast {
        def testname = "B6361557"
        println jvmArgs
        println systemProperties
        def props = systemProperties
        javaexec {
            classpath sourceSets.testMains.runtimeClasspath
            main testname
            systemProperties = props
            // debug true
        }
    }
}

task testMainsTest(type: Test) { 
    dependsOn testMainsClasses
    doLast {
        def files = sourceSets.testMains.allJava
        def is = System.in
        files.each { file ->
            def fileWithoutExt = file.name.take(file.name.lastIndexOf('.'))
            def props = systemProperties
            println " *** $fileWithoutExt ***"
            javaexec {
                classpath sourceSets.testMains.runtimeClasspath
                main fileWithoutExt
                systemProperties props
                standardInput is
            }
        }
    }
}

task runSimpleFileServer(type: JavaExec) { 
    doFirst {
        mkdir 'fileserver'
    }
    dependsOn testClasses
    classpath sourceSets.test.runtimeClasspath
    
    // FIX 1: Use 'mainClass' instead of 'main'
    // FIX 2: Replace "SimpleFileServer" with the FULLY QUALIFIED class name
    // (e.g., if it's in a package named com.example)
    mainClass = "com.example.SimpleFileServer" 
    
    args = ['fileserver','443','fileserver/logfile.txt']
    
    javaLauncher = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(23)
    }
}

task testJar(type: Jar) {
    archiveClassifier.set("test")
    from sourceSets.test.output, sourceSets.testMains.output
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

task runAllTests(type: Test) {
    dependsOn test
    dependsOn testMainsTest
}

publish {
    dependsOn runAllTests
}

publishing {
    publications {
        maven(MavenPublication) {
            groupId = 'io.github.robaho'
            artifactId = 'httpserver'

            from components.java

            pom {
                name = 'HttpServer'
                description = 'A zero dependency implementation of the JDK httpserver designed for Virtual Threads. Includes websocket and Http2 support.'

                signing {
                    sign publishing.publications.maven
                    sign configurations.archives
                }

                url = 'https://github.com/robaho/httpserver'

                scm {
                    url = 'https://github.com/robaho/httpserver.git'
                }

                licenses {
                    license {
                        name = 'gnu v2.0 with classpath exception'
                        url = 'https://www.gnu.org/software/classpath/license.html'
                    }
                    license {
                        name = 'nanohttpd'
                        url = 'https://github.com/NanoHttpd/nanohttpd/blob/efb2ebf85a2b06f7c508aba9eaad5377e3a01e81/LICENSE.md'
                    }
                    license {
                        name = 'MIT License'
                        url = 'https://opensource.org/licenses/MIT'
                    }
                }

                developers {
                    developer {
                        id = 'robaho'
                        name = 'Robert Engels'
                        email = 'robaho@me.com'
                    }
                }
            }
        }
    }
}

mavenCentral {
    def tokenString = "${maven_user}:${maven_password}"
    def token = tokenString.bytes.encodeBase64().toString()
    authToken = token
    // Whether the upload should be automatically published or not. Use 'USER_MANAGED' if you wish to do this manually.
    // This property is optional and defaults to 'AUTOMATIC'.
    publishingType = 'AUTOMATIC'
    // Max wait time for status API to get 'PUBLISHING' or 'PUBLISHED' status when the publishing type is 'AUTOMATIC',
    // or additionally 'VALIDATED' when the publishing type is 'USER_MANAGED'.
    // This property is optional and defaults to 60 seconds.
    maxWait = 60
}
